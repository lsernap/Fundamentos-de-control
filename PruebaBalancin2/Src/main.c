/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stm32f4xx.h>
#include <stdint.h>

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
//#include <arm_math.h>

#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"
#include "exti_driver_hal.h"
#include "usart_driver_hal.h"
#include "PwmDriver.h"
#include "adc_driver_hal.h"

void initSystem(void);

//-------------------- definicion de los handlers necesarios en el programa --------------------//

/* uso del USART 2 con los pines A2 y A3  que estan conectados directamente al cable usb */
GPIO_Handler_t pinTx         = {0};   //PinA2
GPIO_Handler_t pinRx         = {0};   //PinA3
USART_Handler_t commSerial   = {0};
Timer_Handler_t PruebaTimer  = {0};  //timer 5
ADC_Config_t potenciometro1  = {0};

/* GPIO de salida de pwm para el motor*/
GPIO_Handler_t motor          = {0}; //Pin A6
PWM_Handler_t pwm_motor       = {0}; //Timer 3
//-------------------- definicion de las variables  ------------------------------------//
uint8_t sendMsg       = 0;
uint16_t valor        = 0;
uint16_t anguloT      = 10;  //el angulo varia entre 10° y 150°
uint16_t anguloMed    = 0;
uint16_t dutty_motor = 10;
uint8_t receivedChar  = '\0';
char bufferData[128]  = {0};


int main(void){
	initSystem();

    /* Loop forever */
	while(1){

		if (receivedChar) {
			if (receivedChar == 'p') {
				usart_writeMsg(&commSerial, "Testing, Testing\n\r");
			}
			else if (receivedChar == 'n') {
				sprintf(bufferData, "Set Point(Angulo): %d \n", anguloT);
				usart_writeMsg(&commSerial, bufferData);
			}
			else if (receivedChar == 'w'){
				if (anguloT < 150){
					anguloT = anguloT + 5;
					//updateDuttyCycle(&pwm_azul, dutty_motor);
				}
				else {
					anguloT = 150;
				}
			}
			receivedChar = '\0';
		}
	}

	return 0;
}
/* funcion que atiende la interrupcion del usart */
void usart2_RxCallback(void) {
	receivedChar = usart_getRxData();
}
/* funcion que atiende la interrupcion del timer de prueba */
void timer5_Callback(void){
	adc_StartSingleConv();
	sprintf(bufferData, "Angulo Medido: %d \n", anguloMed);
	usart_writeMsg(&commSerial, bufferData);

}
/* funcion que atiende la interrupcion del adc */
void adc_CompleteCallback(void) {
	potenciometro1.adcData = adc_GetValue();
	valor = potenciometro1.adcData;
	anguloMed = valor;
}


void initSystem(void){
/*-------------------Configuramos los pines del puerto serial ------------------*/
	/* Pin sobre los que funciona el USART2 (TX)*/
	pinTx.GPIOx = GPIOA;
	pinTx.pinConfig.GPIO_PinNumber = PIN_2;
	pinTx.pinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	pinTx.pinConfig.GPIO_PinAltFunMode = AF7;
	pinTx.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	gpio_Config(&pinTx);

	/* Pin Rx*/
	pinRx.GPIOx = GPIOA;
	pinRx.pinConfig.GPIO_PinNumber = PIN_3;
	pinRx.pinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	pinRx.pinConfig.GPIO_PinAltFunMode = AF7;
	pinRx.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	pinRx.pinConfig.GPIO_PinOutputSpeed = GPIO_OSPEED_MEDIUM;
	gpio_Config(&pinRx);

	/* Configuramos el pueto serial (USART2)*/
	commSerial.ptrUSARTx = USART2;
	commSerial.USART_Config.baudrate = USART_BAUDRATE_115200;
	commSerial.USART_Config.datasize = USART_DATASIZE_8BIT;
	commSerial.USART_Config.parity = USART_PARITY_NONE;
	commSerial.USART_Config.stopbits = USART_STOPBIT_1;
	commSerial.USART_Config.mode = USART_MODE_RXTX;
	commSerial.USART_Config.enableIntRX = USART_RX_INTERRUP_ENABLE;
	usart_Config(&commSerial);
	usart_WriteChar(&commSerial, '\0');

	/*Configuramos el timer para el toma de datos*/
	PruebaTimer.pTIMx                                = TIM5;
	PruebaTimer.TIMx_Config.TIMx_Prescaler           = 16000;   // Genera incrementos de 1 ms
	PruebaTimer.TIMx_Config.TIMx_Period              = 5000;      // De la mano con el prescaler
	PruebaTimer.TIMx_Config.TIMx_mode                = TIMER_UP_COUNTER;
	PruebaTimer.TIMx_Config.TIMx_InterruptEnable     = TIMER_INT_ENABLE;
	timer_Config(&PruebaTimer);
	timer_SetState(&PruebaTimer,TIMER_ON);

	//Configuramos la conversion ADC//
	potenciometro1.channel = ADC_CHANNEL_4;
	potenciometro1.resolution = ADC_RESOLUTION_12_BIT;
	potenciometro1.dataAlignment = ADC_ALIGNMENT_RIGHT;
	potenciometro1.samplingPeriod = SAMPLING_PERIOD_84_CYCLES;
	potenciometro1.interrupState = ADC_INT_ENABLE;
	adc_ConfigSingleChannel(&potenciometro1);
	adc_peripheralOnOFF(ADC_ON);

/*-----------------Configuramos el pin para el Motor y su PWM-----------------*/
    /* GPIO */
    motor.GPIOx                              = GPIOA;
    motor.pinConfig.GPIO_PinNumber           = PIN_6;
    motor.pinConfig.GPIO_PinMode             = GPIO_MODE_ALTFN;
    motor.pinConfig.GPIO_PinAltFunMode       = AF2;
    motor.pinConfig.GPIO_PinOutputType       = GPIO_OTYPE_PUSHPULL;
    motor.pinConfig.GPIO_PinOutputSpeed      = GPIO_OSPEED_MEDIUM;
    motor.pinConfig.GPIO_PinPuPdControl      = GPIO_PUPDR_NOTHING;
    gpio_Config(&motor);
    /* PWM */
    pwm_motor.ptrTIMx                               = TIM3;
    pwm_motor.config.channel                        = PWM_CHANNEL_1;
    pwm_motor.config.prescaler                      = 16;
    pwm_motor.config.periodo                        = 20000;
    pwm_motor.config.duttyCicle                     = 10;
    pwm_Config(&pwm_motor);
    startPwmSignal(&pwm_motor);

}
