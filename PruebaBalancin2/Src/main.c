/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stm32f4xx.h>
#include "stm32_assert.h"

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <arm_math.h>
#include <float.h>

#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"
#include "exti_driver_hal.h"
#include "usart_driver_hal.h"
#include "PwmDriver.h"
#include "adc_driver_hal.h"

void initSystem(void);
void Control_PI(void);

//-------------------- definicion de los handlers necesarios en el programa --------------------//

/* uso del USART 2 con los pines A2 y A3  que estan conectados directamente al cable usb */
GPIO_Handler_t pinTx         = {0};   //PinA2
GPIO_Handler_t pinRx         = {0};   //PinA3
USART_Handler_t commSerial   = {0};
Timer_Handler_t PruebaTimer  = {0};  //timer 5
ADC_Config_t potenciometro1  = {0};  //Pin A4

/* GPIO de salida de pwm para el motor*/
GPIO_Handler_t motor          = {0}; //Pin A6
PWM_Handler_t pwm_motor       = {0}; //Timer 3

//-------------------- definicion de las variables  ------------------------------------//

#define     TS_MS       50      // Periodo de muestreo en ms (50 ms)
#define     TS_SEC      (float32_t)(TS_MS / 1000.0f) // Periodo de muestreo en segundos (0.05 s)

float32_t Kp = 14.60f;     // Ganancia Proporcional (P)
float32_t Ki = 2.2f;    // Ganancia Integral (I)

// Variables de estado del PI
float32_t error        = 0.0f; // Error actual
float32_t error_a      = 0.0f; // Error anterior
float32_t u_k          = 0.0f; // Salida del controlador actual (señal de control, Dutty Cycle)
float32_t u_k_1        = 0.0f; // Salida del controlador anterior

uint8_t sendMsg       = 0;
uint16_t valor        = 0;
uint16_t anguloT      = 90;  //el angulo varia entre 10° y 150°
float32_t anguloMed    = 0;
uint16_t dutty_motor = 10;
uint8_t receivedChar  = '\0';
char bufferData[128]  = {0};


int main(void){
	initSystem();

    /* Loop forever */
	while(1){

		if (receivedChar) {
			if (receivedChar == 'p') {
				usart_writeMsg(&commSerial, "Testing, \n\r");
				updateDuttyCycle(&pwm_motor,200);
			}
			else if (receivedChar == 'n') {
				sprintf(bufferData, "Set Point(Angulo): %d \n", anguloT);
				usart_writeMsg(&commSerial, bufferData);
				sprintf(bufferData, "Angulo Medido: %.2f \n", anguloMed);
				usart_writeMsg(&commSerial, bufferData);
				sprintf(bufferData, "error: %.2f \n", error);
				usart_writeMsg(&commSerial, bufferData);

			}
			else if (receivedChar == 'd'){
				Kp= Kp - 0.1f;
				sprintf(bufferData, "error: %.2f \n", Kp);
				usart_writeMsg(&commSerial, bufferData);

			}
			else if (receivedChar == 'w'){
				if (anguloT < 100){
					anguloT = anguloT + 5;
				}
				else {
					anguloT = 100;
				}
			}
			else if (receivedChar == 's'){
				//Ki = Ki + 0.1f;
				//sprintf(bufferData, "error: %.2f \n", Ki);
				//usart_writeMsg(&commSerial, bufferData);
				if (anguloT > 50){
					anguloT = anguloT - 5;
				}
				else {
					anguloT = 50;
				}
			}
			receivedChar = '\0';
		}
	}

	return 0;
}
/* funcion que atiende la interrupcion del usart */
void usart2_RxCallback(void) {
	receivedChar = usart_getRxData();
}
/* funcion que atiende la interrupcion del timer de prueba */
void timer5_Callback(void){
	adc_StartSingleConv();
//	sprintf(bufferData, "Angulo Medido: %d \n", valor);
//	usart_writeMsg(&commSerial, bufferData);


}
/* funcion que atiende la interrupcion del adc */
void adc_CompleteCallback(void) {
	potenciometro1.adcData = adc_GetValue();
	valor = potenciometro1.adcData;
	anguloMed = ((float32_t)valor * -(0.86f)) + 3090.0f ;
	Control_PI(); // ejecutamos el algoritmo de control PI
}

void Control_PI(void){
	//1. Calculo del error
	error = (float32_t)anguloT - anguloMed;
	//2. Calculo de la accion proporcional
	float32_t terminoP = Kp * (error - error_a);
	//3. Calculo de la accion integral
	float32_t terminoI = Ki * TS_SEC * error;
	//4. Incremento de la salida de control
	float32_t delta_u = terminoP + terminoI;
	//5.salida de control actual
	u_k = u_k_1 + delta_u;
	//6. Anti-windup (limitacion de la salida)
	if (u_k > 20000.0f){
		u_k = 20000.0f;
	}
	else if (u_k < 0.0f){
		u_k = 0.0f;
	}
	//7. Asignar la salida de control al PWM
	float32_t esc_dutty_float = 100.0f + (u_k / 20000.0f) * (200.0f - 100.0f); // Rango [100.0, 200.0]
	dutty_motor = (uint16_t)esc_dutty_float;
	updateDuttyCycle(&pwm_motor,dutty_motor);

	// Asegurar los límites de hardware
    if (dutty_motor < 100) dutty_motor = 100;
	if (dutty_motor > 200) dutty_motor = 200;
	//8. actualizar la variable para la proxima iteracion
	error_a = error;
	u_k_1 = u_k;
}

void initSystem(void){
/*-------------------Configuramos los pines del puerto serial ------------------*/
	/* Pin sobre los que funciona el USART2 (TX)*/
	pinTx.GPIOx = GPIOA;
	pinTx.pinConfig.GPIO_PinNumber = PIN_2;
	pinTx.pinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	pinTx.pinConfig.GPIO_PinAltFunMode = AF7;
	pinTx.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	gpio_Config(&pinTx);

	/* Pin Rx*/
	pinRx.GPIOx = GPIOA;
	pinRx.pinConfig.GPIO_PinNumber = PIN_3;
	pinRx.pinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	pinRx.pinConfig.GPIO_PinAltFunMode = AF7;
	pinRx.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	pinRx.pinConfig.GPIO_PinOutputSpeed = GPIO_OSPEED_MEDIUM;
	gpio_Config(&pinRx);

	/* Configuramos el pueto serial (USART2)*/
	commSerial.ptrUSARTx = USART2;
	commSerial.USART_Config.baudrate = USART_BAUDRATE_115200;
	commSerial.USART_Config.datasize = USART_DATASIZE_8BIT;
	commSerial.USART_Config.parity = USART_PARITY_NONE;
	commSerial.USART_Config.stopbits = USART_STOPBIT_1;
	commSerial.USART_Config.mode = USART_MODE_RXTX;
	commSerial.USART_Config.enableIntRX = USART_RX_INTERRUP_ENABLE;
	usart_Config(&commSerial);
	usart_WriteChar(&commSerial, '\0');

/*----------------Configuramos el timer para el toma de datos---------------*/
	PruebaTimer.pTIMx                                = TIM5;
	PruebaTimer.TIMx_Config.TIMx_Prescaler           = 16000;   // Genera incrementos de 1 ms
	PruebaTimer.TIMx_Config.TIMx_Period              = TS_MS;      // De la mano con el prescaler
	PruebaTimer.TIMx_Config.TIMx_mode                = TIMER_UP_COUNTER;
	PruebaTimer.TIMx_Config.TIMx_InterruptEnable     = TIMER_INT_ENABLE;
	timer_Config(&PruebaTimer);
	timer_SetState(&PruebaTimer,TIMER_ON);

/*----------------Configuramos la conversion ADC--------------------*/
	potenciometro1.channel = ADC_CHANNEL_4;
	potenciometro1.resolution = ADC_RESOLUTION_12_BIT;
	potenciometro1.dataAlignment = ADC_ALIGNMENT_RIGHT;
	potenciometro1.samplingPeriod = SAMPLING_PERIOD_84_CYCLES;
	potenciometro1.interrupState = ADC_INT_ENABLE;
	adc_ConfigSingleChannel(&potenciometro1);
	adc_peripheralOnOFF(ADC_ON);

/*-----------------Configuramos el pin para el Motor y su PWM-----------------*/
    /* GPIO */
    motor.GPIOx                              = GPIOA;
    motor.pinConfig.GPIO_PinNumber           = PIN_6;
    motor.pinConfig.GPIO_PinMode             = GPIO_MODE_ALTFN;
    motor.pinConfig.GPIO_PinAltFunMode       = AF2;
    motor.pinConfig.GPIO_PinOutputType       = GPIO_OTYPE_PUSHPULL;
    motor.pinConfig.GPIO_PinOutputSpeed      = GPIO_OSPEED_MEDIUM;
    motor.pinConfig.GPIO_PinPuPdControl      = GPIO_PUPDR_NOTHING;
    gpio_Config(&motor);
    /* PWM */
    pwm_motor.ptrTIMx                               = TIM3;
    pwm_motor.config.channel                        = PWM_CHANNEL_1;
    pwm_motor.config.prescaler                      = 160;
    pwm_motor.config.periodo                        = 2000;
    pwm_motor.config.duttyCicle                     = 200;
    pwm_Config(&pwm_motor);
    startPwmSignal(&pwm_motor);

}
