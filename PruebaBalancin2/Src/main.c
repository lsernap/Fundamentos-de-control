/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stm32f4xx.h>
#include <stdint.h>

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"
#include "exti_driver_hal.h"
#include "usart_driver_hal.h"
#include "PwmDriver.h"
#include "adc_driver_hal.h"

//-------------------- definicion de los handlers necesarios en el programa --------------------//
/* uso del USART 2 con los pines A2 y A3  que estan conectados directamente al cable usb */
GPIO_Handler_t pinTx        = {0};   //PinA2
GPIO_Handler_t pinRx        = {0};   //PinA3

USART_Handler_t commSerial  = {0};
Timer_Handler_t PruebaTimer = {0};
ADC_Config_t potenciometro1  = {0};
//-------------------- definicion de las variables globales ------------------------------------//
uint8_t sendMsg      = 0;
uint16_t valor       = 0;
uint8_t receivedChar = '\0';
char bufferData[128] = {0};

int main(void){
	/*Configuramos los pines del puerto serial */
	/* Pin sobre los que funciona el USART2 (TX)*/
	pinTx.GPIOx = GPIOA;
	pinTx.pinConfig.GPIO_PinNumber = PIN_2;
	pinTx.pinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	pinTx.pinConfig.GPIO_PinAltFunMode = AF7;
	pinTx.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	gpio_Config(&pinTx);

	/* Pin Rx*/
	pinRx.GPIOx = GPIOA;
	pinRx.pinConfig.GPIO_PinNumber = PIN_3;
	pinRx.pinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	pinRx.pinConfig.GPIO_PinAltFunMode = AF7;
	pinRx.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	pinRx.pinConfig.GPIO_PinOutputSpeed = GPIO_OSPEED_MEDIUM;
	gpio_Config(&pinRx);

	/* Configuramos el pueto serial (USART2)*/
	commSerial.ptrUSARTx = USART2;
	commSerial.USART_Config.baudrate = USART_BAUDRATE_115200;
	commSerial.USART_Config.datasize = USART_DATASIZE_8BIT;
	commSerial.USART_Config.parity = USART_PARITY_NONE;
	commSerial.USART_Config.stopbits = USART_STOPBIT_1;
	commSerial.USART_Config.mode = USART_MODE_RXTX;
	commSerial.USART_Config.enableIntRX = USART_RX_INTERRUP_ENABLE;
	usart_Config(&commSerial);
	usart_WriteChar(&commSerial, '\0');

	/*Configuramos el timer para el toma de datos*/
	PruebaTimer.pTIMx                                = TIM5;
	PruebaTimer.TIMx_Config.TIMx_Prescaler           = 16000;   // Genera incrementos de 1 ms
	PruebaTimer.TIMx_Config.TIMx_Period              = 5000;      // De la mano con el prescaler
	PruebaTimer.TIMx_Config.TIMx_mode                = TIMER_UP_COUNTER;
	PruebaTimer.TIMx_Config.TIMx_InterruptEnable     = TIMER_INT_ENABLE;
	timer_Config(&PruebaTimer);
	timer_SetState(&PruebaTimer,TIMER_ON);

	//Configuramos la conversion ADC//
	potenciometro1.channel = ADC_CHANNEL_4;
	potenciometro1.resolution = ADC_RESOLUTION_12_BIT;
	potenciometro1.dataAlignment = ADC_ALIGNMENT_RIGHT;
	potenciometro1.samplingPeriod = SAMPLING_PERIOD_84_CYCLES;
	potenciometro1.interrupState = ADC_INT_ENABLE;
	adc_ConfigSingleChannel(&potenciometro1);
	adc_peripheralOnOFF(ADC_ON);

    /* Loop forever */
	while(1){

		if (receivedChar) {
			if (receivedChar == 'p') {
				usart_writeMsg(&commSerial, "Testing, Testing\n\r");
			}
			else if (receivedChar == 'n') {
				sprintf(bufferData, "Valor X es: %d \n", valor);
				usart_writeMsg(&commSerial, bufferData);

			}
			receivedChar = '\0';
		}
	}

	return 0;
}
/* funcion que atiende la interrupcion del usart */
void usart2_RxCallback(void) {
	receivedChar = usart_getRxData();
}
/* funcion que atiende la interrupcion del timer de prueba */
void timer5_Callback(void){
	adc_StartSingleConv();
	sprintf(bufferData, "Valor X es: %d \n", valor);
	usart_writeMsg(&commSerial, bufferData);

}
/* funcion que atiende la interrupcion del adc */
void adc_CompleteCallback(void) {
	potenciometro1.adcData = adc_GetValue();
	valor = potenciometro1.adcData;
}

